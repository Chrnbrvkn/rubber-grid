Rubber Grid

    Всем привет! Вместе со своей командой я придумал удобный для себя способ расположения
элементов используя свойство CSS grid. Существует множество различных вариантов их позиционирования,
для каждого случая нужно подбирать уникальное сочетание CSS свойств и единиц измерения. Я предлагаю
расставлять элементы всегда по одному и тому же принципу, по относительному позиционированию
в заданной grid сетке вот так:

    1) Родительскому элементу задаём свойства:
        display: grid;
        grid-template-columns: repeat( width, 1fr);  // width and height указываем без px
        grid-template-rows: repeat( height, 1fr);

        Функция repeat() принимает 2 параметра, количество столбцов или строк и размер столбца или строки.
    1fr - это фракция, единица измерения сделанная специально для grid свойств, она очень гибкая и 
    занимает всё свободное пространство пропорционально разделяя его между остальными фракциями.
        С помощью этих свойств мы создаём сетку, где количество столбцом и строк будет равно значению width и height,
    а ширина и высоста 1 ячейки будет равна 1fr. 

    2) Дочернему элементу мы назначаем свойство grid-area, это сокращённая запись 4 других свойств:
      grid-area: grid-row-start/ grid-column-start/ grid-row-end/ grid-column-end;
      grid-row-start и grid-column-start это номер столбца и колонки, откуда начинается наш вложенный элемент,
      grid-row-end и grid-column-end номер столбца и колонки, на которых он заканчивается.
    
    Если посмотреть на макет в Фигме или Pixso, то мы увидим 4 основных свойства определяющие положение и размер
    элемента: top/bottom, left/right, width, height. Свойство grid-area можно использовать по-разному, здесь нас 
    интересует ключевое слово "span", оно позволяет взять определённое количество столбцов или строк. Использовать
    его можно для свойств grid-row-end и grid-column-end.
    grid-area позволяет нам захватить определённое количество ячеек в нашей сетке, что соответствует этой формуле:

    grid-area: top/left/ span height/ span width;  //значения указываем без px
    
    * дочерний элемент начинается со строки равной top и включает в себя "span height" строк;
      начинается с колонки равной left и включает в себя "span width" колонок.

    3) Максимальную резиновость макета можно сделать используя гибкие величины для родительского width и height
    (vw, vh, % и другое). Также, если родительский контейнер с нашей сеткой лежит в другом гибком контейнере, 
    то он на всё свободное пространство проставит наши ячейки и они примут своё пропорциональное положение.
    Но есть нюанс! Даже несколько :с 
        1. Резиновость это здорово, но, чаще всего, нам нужна адаптация только по ширине экрана. Поэтому в свойстве
        grid-template-rows: repeat( height, 1px); размер строки лучше задать в пикселях. У нас будут гибкие колонки и 
        жёсткие строки.
        2. Проблема с текстом. font-size можно задать только 1 раз, или это будут гибкие vw/vh, которые напрямую
        будут зависить от ширины/высоты экрана, или значения в других единицах измерения, но они могут некорректно
        себя вести при разных разрешениях (вылезать за пределы контейнера, наезжать друг на друга). 
        Величины vw и vh могут сделать контент нечитабельным, если на большом мониторе уменьшить размеры браузера, чтобы
        решить эту проблему их можно переназначить в медиа на другую конкретную величину.
        В остальных случаях можно задать min-width / min-height такие, чтобы наш элемент не становился меньше своего
        контента (компилятор на этом сайте может автоматически выдать вам эти свойства). 
        3. Из конца второго пункта вытекает следующая проблема, но она тоже решаема, не переживайте. С помощью компилятора 
        по абсолютному позиционированию можно проставить все элементы, но в таком случае каждая строка и колонка будут друг
        от друга зависить. Если у нас есть блок, который мы не хотим уменьшать и задали ему негибкую величину, соответственно 
        столбцы и строки за пределами этого блока уменьшаться также не будут, это повлияет на гибкость остальных элементов.
        Чтобы такого не происходило нужно создавать "родителей" "полосами" ( разбейте ваш макет на несколько полос от первого
        до последнего столбца и перерасчитайте координаты top и left на относительные). 

    4) Дополнительная информация.

    Строки и столбцы начинаются с 1, у них нет отрицательных и нулевых значений. 

    Относительные значения top и left рассчитываются следующим образом:
    topRelative = parentHeight - childrenHeight 
    leftRelative = parentWidth - childrenWidth


/// возможно это херня и можно полегче сделать
    Центрировать всю видимую часть контента можно по-разному, мне понравился вот такой способ:
        Создаём div в body и делаем ему сетку из 3х колонок размерами 1fr

        display: grid;
        grid-template-columns: repeat(3,1fr);

        С помощью свойства  grid-column: 2/3; обозначаем положение основного контейнера, где будет наш макет,    
        перезадаём ему ширину с 1fr на width: 100vw;
        У нас получается div в котором 3 колонки, колонка в центре всегда равной 100% ширине экрана, колонки по бокам равны 1fr.






Короткий гайд для тех, кто уже знаком с grid layout:

В родительском контейнере создаём попиксельную сетку соответствующую значениям на макете

        display: grid;
        grid-template-columns: repeat( width, 1fr);  // width and height указываем без px
        grid-template-rows: repeat( height, 1fr);

Назначаем ячейки, где будет располагаться дочерний элемент по этой формуле:

        grid-area: top/left/ span height/ span width;  // значения приводим к px и указываем без единиц измерения
